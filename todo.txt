FonctionnalitÃ©s dÃ©jÃ  prÃ©sentes (Ã  maintenir et amÃ©liorer)

Ã‰coute sur plusieurs ports

Gestion basique des connexions avec select()

RÃ©ponse HTTP 1.1 avec headers Content-Type, Content-Length, Connection

Lecture et envoi de fichiers statiques (html, css, png, etc.)

Page 404 par dÃ©faut

Extraction de la route depuis la requÃªte HTTP

Affichage des requÃªtes reÃ§ues (via printf)

    Fermeture propre des sockets

ğŸ› ï¸ Ã€ amÃ©liorer / Ã  corriger

    Utilisation de select() â†’ remplacer par poll() (ou epoll, kqueue)

        âŒ select() est utilisÃ©, or le sujet impose l'utilisation de poll() ou Ã©quivalent pour toutes les opÃ©rations I/O.

        âœ… Ã€ faire :

            Remplacer select() par poll() dans Server::start()

            Utiliser POLLIN et POLLOUT pour gÃ©rer lecture/Ã©criture

            GÃ©rer tous les clients connectÃ©s simultanÃ©ment, non pas les refuser aprÃ¨s accept

    RequÃªtes non-bloquantes

        Le serveur lit immÃ©diatement la requÃªte aprÃ¨s accept() (via read()), ce qui est bloquant si aucune donnÃ©e nâ€™est disponible.

        âœ… Ã€ faire :

            Marquer tous les descripteurs (listen et client) en non-bloquant avec fcntl(fd, F_SETFL, O_NONBLOCK)

            Ne jamais appeler read() ni write() sans poll() prÃ©alable

            Lire par morceaux (bufferisation des requÃªtes incomplÃ¨tes)

    Gestion des connexions simultanÃ©es

        Actuellement, le serveur accepte une connexion, traite, puis ferme immÃ©diatement.

        âœ… Ã€ faire :

            Conserver les connexions actives (clients) dans une structure (std::map<int, Connexion>)

            ImplÃ©menter une boucle dâ€™analyse et rÃ©ponse non-bloquante par client

            Respecter la directive "ne jamais bloquer une requÃªte, ni bloquer un thread"

    Structure du code : sÃ©paration logique

        âœ… Ã€ faire :

            CrÃ©er une classe Connection ou ClientHandler pour stocker :

                FD client

                Ã©tat de lecture / Ã©criture

                buffer de requÃªte

                buffer de rÃ©ponse

                Ã©tat de la connexion (en cours, fermÃ©e, etc.)

    Support HTTP incomplet

        âŒ Seul GET est gÃ©rÃ© (et partiellement)

        âœ… Ã€ faire :

            ImplÃ©menter correctement le parsing complet de la requÃªte HTTP :

                Ligne de commande (mÃ©thode, chemin, version)

                Headers (au moins Host, Content-Length, etc.)

                Body pour POST

        âœ… ImplÃ©menter les mÃ©thodes suivantes :

GET

POST (ex. : upload fichier, ou renvoyer formulaire simulÃ©)

            DELETE

    Configuration serveur

        âŒ Aucun parsing de fichier de configuration .conf

        âœ… Ã€ faire :

            GÃ©rer un fichier de conf (ex. : config.conf)

                Ports

                Racine (root)

                Pages dâ€™erreur (error_page)

                Emplacements (location { ... })

                MÃ©thodes autorisÃ©es

            CrÃ©er une classe Config pour parser et stocker les directives

ğŸš€ Ã€ implÃ©menter obligatoirement (non prÃ©sent pour lâ€™instant)
ğŸ”„ FonctionnalitÃ©s HTTP

MÃ©canisme de keep-alive / connection: close

Headers conformes Ã  HTTP/1.1

Codes dâ€™Ã©tat HTTP corrects (200, 404, 405, 413, 500, etc.)

    Gestion des erreurs (400, 403, 500, etc.) avec pages personnalisÃ©es

ğŸ“¤ Support fichiers statiques

Support du tÃ©lÃ©chargement de fichiers (Content-Disposition: attachment)

    Support de fichiers binaires de grande taille (streamÃ©)

ğŸ§ª Tests & compatibilitÃ© navigateur

Tester avec curl, telnet, navigateurs modernes (Chrome, Firefox)

    Comparer comportement avec NGINX sur cas similaires

ğŸ“„ Gestion du POST

Lecture du body (Content-Length)

Formulaire HTML simulant un upload

    Ã‰criture du body dans un fichier (upload fictif)

ğŸ”§ Gestion de CGI (avec fork(), dup2(), etc.)

Support de scripts CGI (ex. PHP, Python)

Lecture de la sortie standard du script

    Mapping /cgi-bin/ ou Ã©quivalent dans la config

ğŸ§ª Stress & stabilitÃ©

Test de plusieurs centaines de connexions simultanÃ©es (outil : ab, siege, ou script Python asyncio)

Timeout inactifs (pas de connexion bloquÃ©e)

    DÃ©tection & fermeture des clients inactifs

ğŸ§¼ Divers

Ne pas utiliser errno aprÃ¨s read()/write() (comme mentionnÃ© dans le sujet)

Logger toutes les connexions entrantes et requÃªtes

    GÃ©rer le SIGINT pour fermeture propre du serveur (Ctrl+C)

ğŸ’¡ Conseils

    Commence par remplacer select() par poll() avec une structure de clients active

    ImplÃ©mente le GET de maniÃ¨re non-bloquante

    Puis ajoute POST, DELETE

    Ensuite, ajoute le parsing du fichier de configuration

    Termine par le support CGI